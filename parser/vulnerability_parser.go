package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

func main() {
	var vr VulnReport

	if len(os.Args) != 2 {
		fmt.Printf("Usage:\n vulnerbility_parser <FILE>\n")
		os.Exit(1)
	}

	b, err := ioutil.ReadFile(os.Args[1])
	if err != nil {
		panic(err)
	}

	err = json.Unmarshal(b, &vr)
	if err != nil {
		fmt.Println("Error parsing JSON file to predefined struct")
		panic(err)
	}

	critical := vr.PackageVulnerabilitySummary.Vulnerabilities.CRITICAL
	high := vr.PackageVulnerabilitySummary.Vulnerabilities.HIGH
	medium := vr.PackageVulnerabilitySummary.Vulnerabilities.MEDIUM
	low := vr.PackageVulnerabilitySummary.Vulnerabilities.LOW
	numOfCriticalFixes := 0

	fmt.Println("-------------------------------------------------------")
	fmt.Println("VULNERABILITY SUMMARY")
	fmt.Println("-------------------------------------------------------")
	fmt.Println("Critical Vulnerabilities:", len(critical))
	fmt.Println("High Vulnerabilities:", len(high))
	fmt.Println("Medium Vulnerabilities:", len(medium))
	fmt.Println("Low Vulnerabilities:", len(low))
	fmt.Println()

	if len(critical) > 0 {
		fmt.Println("-------------------------------------------------------")
		fmt.Println("CRITICAL PACKAGE ISSUES")
		fmt.Println("-------------------------------------------------------")
		for _, v := range critical {
			nna := strings.Split(v.NoteName, "/")
			fmt.Println("PACKAGE ISSUE:", nna[len(nna)-1])
			for _, j := range v.VulnerabilityDetails.PackageIssue {
				fmt.Printf("\tAFFECTED LOCATION\n")
				fmt.Printf("\t\tCPE URI: %s\n", j.AffectedLocation.CpeURI)
				fmt.Printf("\t\tPACKAGE: %s\n", j.AffectedLocation.Package)
				fmt.Printf("\t\tVERSION: %s:%s\n", j.AffectedLocation.Version.Name, j.AffectedLocation.Version.Revision)

				if j.FixedLocation.CpeURI != "" {
					numOfCriticalFixes++
					fmt.Printf("\tFIXED LOCATION\n")
					fmt.Printf("\t\tCPE URI: %s\n", j.FixedLocation.CpeURI)
					fmt.Printf("\t\tPACKAGE: %s\n", j.FixedLocation.Package)
					fmt.Printf("\t\tVERSION: %s\n", j.FixedLocation.Version.Kind)
				}
				fmt.Println()
			}
		}
		fmt.Print("SPINNAKER_PROPERTY_critical_vulnerabilities=", len(critical), "\n")
		fmt.Print("SPINNAKER_PROPERTY_high_vulnerabilities=", len(high), "\n")
		fmt.Print("SPINNAKER_PROPERTY_medium_vulnerabilities=", len(medium), "\n")
		fmt.Print("SPINNAKER_PROPERTY_low_vulnerabilities=", len(low), "\n")
		fmt.Print("SPINNAKER_PROPERTY_critical_fixes=", numOfCriticalFixes, "\n")
	}
}

type VulnReport struct {
	PackageVulnerabilitySummary struct {
		Vulnerabilities            struct {
			CRITICAL []Vulnerability `json:"CRITICAL"`
			HIGH     []Vulnerability `json:"HIGH"`
			LOW      []Vulnerability `json:"LOW"`
			MEDIUM   []Vulnerability `json:"MEDIUM"`
			None     []Vulnerability `json:"None"`
		} `json:"vulnerabilities"`
	} `json:"package_vulnerability_summary"`
}

type Vulnerability struct {
	NoteName   string `json:"noteName"`
	VulnerabilityDetails struct {
		CvssScore         float64 `json:"cvssScore"`
		EffectiveSeverity string  `json:"effectiveSeverity"`
		PackageIssue      []struct {
			AffectedLocation struct {
				CpeURI  string `json:"cpeUri"`
				Package string `json:"package"`
				Version struct {
					Name     string `json:"name"`
					Revision string `json:"revision"`
				} `json:"version"`
			} `json:"affectedLocation"`
			FixedLocation struct {
				CpeURI  string `json:"cpeUri"`
				Package string `json:"package"`
				Version struct {
					Name     string `json:"name"`
					Revision string `json:"revision"`
					Kind     string `json:"kind"`
				} `json:"version"`
			} `json:"fixedLocation"`
		} `json:"packageIssue"`
	} `json:"vulnerabilityDetails"`
}
